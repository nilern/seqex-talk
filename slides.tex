\documentclass{beamer}

\usepackage[utf8]{inputenc}

\title{Structure and Interpretation of Malli Regex Schemas}
\author{Pauli Jaakkola}
\date{22.6.2021}

\begin{document}

\frame{\titlepage}

%%%

\begin{frame}

\begin{itemize}
\item The empty string \texttt{\#""} or sequence \texttt{[:cat]}
\item Literal character \texttt{\#"a"} or element schema \texttt{:int}
\item Concatenation \texttt{\#"ab"} or \texttt{[:cat :string :int]}
\item Alternation \texttt{\#"a|b"} or \texttt{[:alt :string :int]}
\item Kleene Star \texttt{\#"a*"} or \texttt{[:* :int]}
\end{itemize}

also

\begin{itemize}
\item Optional \texttt{\#"a?"} or \texttt{[:? :int]}
\item Kleene Plus \texttt{\#"a+"} or \texttt{[:+ :int]}
\item Repeat \texttt{\#"a\{1, 5\}"} or \texttt{[:repeat \{:min 1, :max 5\} :int]}
\end{itemize}

\end{frame}

%%%

\begin{frame}[fragile]

{\scriptsize
\begin{semiverbatim}
(m/parse
  [:schema {:registry {"hiccup" [:or
                                 [:catn
                                  [:name keyword?]
                                  [:props [:? [:map-of keyword? any?]]]
                                  [:children [:* [:schema [:ref "hiccup"]]]]]
                                 [:or nil? boolean? number? string?]]}}
   "hiccup"]
  [:div {:class [:foo :bar]}
   "Hello, world of data"])
;=> {:name :div, :props {:class [:foo :bar]}, :children ["Hello, world of data"]}
\end{semiverbatim}
}

\end{frame}

%%%

\begin{frame}[fragile]

{\scriptsize
\begin{semiverbatim}
(require '[clojure.spec.alpha :as s])

(s/def ::ws (s/* \#(Character/isWhitespace \%)))

(s/def ::sexpr
  (s/cat
    :lws ::ws
    :sexpr (s/alt
             :list (s/cat :lparen \#(= \\( \%)
                          :sexprs (s/* ::sexpr)
                          :rparen #(= \\) \%))
             :symbol (s/cat :c #(Character/isJavaIdentifierStart \%)
                            :cs (s/* #(Character/isJavaIdentifierPart \%)))
             :int (s/+ \#(Character/isDigit \\\}%)))
    :rws ::ws))

(s/valid? ::sexpr (seq "(foo (bar 1 2))"))
; => true

(s/valid? ::sexpr (seq "(foo (bar 1 2)"))
; => false
\end{semiverbatim}
}

\end{frame}

%%%

\begin{frame}

\begin{itemize}
\item \textsc{dfa} (\texttt{grep}, Lex)
\item \textsc{nfa} (Seqexp)
\item Backtracking (\textsc{pcre})
\item Dynamic derivatives (Spec)
\end{itemize}

\end{frame}

%%%

\begin{frame}

\begin{center}
\begin{tabular}{c | c c}
Algorithm & Time usage & Space usage \\
\hline
\textsc{dfa} & \(O(n)\) & \(O(1)\) \\
\textsc{nfa} & \(O(rn)\) & \(O(r)\) \\
Backtracking & \(O(2^n)\) & \(O(n)\) \\
Memoized backtracking & \(O(n)\) & \(O(rn)\) \\
Dynamic derivatives & \(O(rn)\) & \(O(n^r)\)
\end{tabular}
\end{center}

\end{frame}

%%%

\begin{frame}[fragile]

\begin{semiverbatim}
(defn item-parser [parse-item]
  (fn [coll]
    (if (seq coll)
      (let [res (parse-item (first coll))]
        (if-not (miu/-invalid? res)
          [res (rest coll)]
          res))
      :malli.core/invalid)))
\end{semiverbatim}

\begin{semiverbatim}
(defn end-parser [coll]
  (if (empty? coll)
    [nil coll]
    :malli.core/invalid))
\end{semiverbatim}

\end{frame}

%%%

\begin{frame}[fragile]

\begin{semiverbatim}
(defn pure-parser [v] (fn [coll] [v coll]))
\end{semiverbatim}

\begin{semiverbatim}
(defn cat-parser [& parsers]
  (reduce (fn [parser parser*]
            (fn [coll]
              (let [res (parser coll)]
                (if-not (miu/-invalid? res)
                  (let [[vs coll] res]
                    (let [res* (parser* coll)]
                      (if-not (miu/-invalid? res*)
                        (let [[v coll] res*]
                          [(conj vs v) coll])
                        res*)))
                  res))))
          (pure-parser []) parsers))
\end{semiverbatim}

\end{frame}

\end{document}

